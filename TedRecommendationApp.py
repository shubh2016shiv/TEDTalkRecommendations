import streamlit as st
from PIL import Image
import pickle
from sklearn.metrics.pairwise import cosine_similarity
#import webbrowser
import ast
import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.decomposition import TruncatedSVD
import pyperclip as pc

st.set_page_config(layout="wide")
DATA_PATH = './Data/'
cosineSimilarityMatrixCalculated = False

st.title("Project - Recommendation System for TED Talks")
st.subheader("Content Based Recommendation Engine using Natural Language Processing")
image = Image.open(DATA_PATH + "tedImage.jpg")
st.image(image, use_column_width=True)
st.write("----")

st.header("Project Description")
"The project is for recommending TED Talk Videos. The source of Dataset for this project is from TED metadata uploaded on Kaggle.\
 The meta data for TED in English Language contains information in csv format with columns below"

'''
1. talk_id: Official ID
2. title: Title of TED Talk
3. speaker_1: Name of Main speaker 
4. all_speakers: Name of all Speakers in case of multiple speakers
5. about_speakers: Description of speakers
6. views: views of videos
7. published_date
8. event: Associated event name of Ted Talk
9. native_lang: Original Language 
10. available_lang: Available transcript languages
11. related_talks: other talk IDs related to same tags or topic
12. url: URL Link
13. description: Short Description of ted talk
14. transcript
'''
'''
First, TED talk can be searched using favourite topic or tag. The entered interested topics are encoded using Transactional Encoder
to create one dimensional array. The transactional encoding provides the output with hot-encoded values where columns contains all the topics and rows represent all TED Talk titles.\
 Similarity scores are generated using cosine similarity between one dimensional encoded array of \
entered topics and encoded array of all topics from each TED talk titles present in dataset. \
The search results are shown based on top 6 best cosine similarity calculated from topics entered.

Then, after searching the interested TED-Talks, recommendations can be generated for any given favourite TED-talk.\
 These recommendations are generated by pre-processing the text data from transcript, description, speaker and topic of each TED-Talk using Natural Language Processing.\
 Feature extraction is done using "Term-Frequency Inverse Document Frequency(TF-IDF)" vectorization with 1 to 3 n-gram(s) tokens.\
 The output of the TF-IDF vectorization is matrix array of size as 4005 rows and 10000 columns.\
  In order to reduce the size of 10000 columns, dimension reduction technique called Single-Valued Decomposition Algorithm is used,\
  which reduced the 10000 columns to 2000 columns, with loss of just 20% variability. Then, recommendations are generated using\
  cosine similarity matrix of size 40005x40005, where each row denotes the index of the TED-Talk and each column represents\
  cosine similarity score between a TED-Talk at given index and other TED-Talks. Finally, 10 recommendations are generated by selecting best top-10 cosine similarity scores.
'''
st.write("----")


# Functions
def loadPickle(fileName):
    file = open(DATA_PATH + fileName, 'rb')
    object_ = pickle.load(file)
    file.close()
    return object_


@st.cache(show_spinner=False)
def getCosineSimilarityMatrix():
    preProcessedFile = pd.read_csv(DATA_PATH + 'TED_PreProcessedData.csv')
    tfidf_vectorizer = TfidfVectorizer(ngram_range=(1, 3), max_features=10000)
    contentFeatureVectors = tfidf_vectorizer.fit_transform(preProcessedFile['content'])
    svd = TruncatedSVD(n_components=2000)  #
    latent_matrix = svd.fit_transform(contentFeatureVectors)
    return cosine_similarity(latent_matrix, latent_matrix)


def getTalkURL(talk, metadata):
    return metadata[metadata['title'] == talk]['url'].values[0]


def getTalkDescription(talk, metadata):
    return metadata[metadata['title'] == talk]['description'].values[0]


def getRelatedTalks(talk, metadata):
    relatedTalks = ast.literal_eval(metadata[metadata['title'] == talk]['related_talks'].values[0]).values()
    return relatedTalks


def showRecommendation(talk, metadata):
    try:
        st.subheader(talk)
        st.write(getTalkDescription(talk, metadata))
        url = getTalkURL(talk, metadata)
        try:
            if st.button("Get TED Talk Link", key=talk):
                #webbrowser.open_new_tab(url)
                st.info("The Link: {}".format(url))
                #pc.copy(url)
                
        except (Exception,):
            if st.button("Get TED Talk Link", key=url):
                #webbrowser.open_new_tab(url)
                #pc.copy(url)
                st.info("The Link: {}".format(url))

    except (Exception,):
        st.error("Exception Occurred!!")


with st.spinner(text="Performing a crazy calculation. Wait and Grab a coffee â˜•"):
    cosineSimilarityMatrix = getCosineSimilarityMatrix()

st.header("Search TED Talk")

# if st.checkbox(label="Search by TED topics"):
allTedTopics = loadPickle('tedAllTopics.pickle')
st.subheader("Find TED Talk based on tags or your interested topics")
selectTopics = st.multiselect(label="All Multiple topics/tags from below list", options=allTedTopics)
if selectTopics:
    encoder = loadPickle('topicEncoder.pickle')
    encodedSelectedTopics = encoder.transform([selectTopics]).astype('int')
    encodedAllTopics = loadPickle('encodedTopics.pickle')
    topic_similarity_scores = list(
        enumerate(cosine_similarity(encodedAllTopics.values, encodedSelectedTopics)[:, 0]))
    topic_similarity_scores_top10_indices = [index for index, _ in
                                             sorted(topic_similarity_scores, reverse=True, key=lambda x: x[1])[:6]]
    temp = encodedAllTopics.reset_index()  # Will Be deleted later as it is additional dataframe
    top10_talkIds = list(temp.iloc[topic_similarity_scores_top10_indices]['talk_id'].values)
    del temp  # Deleted here to save memory
    talkIds_title_dict = loadPickle('talkID-title_dict.pickle')
    recommendedTalkByTopics = []

    for talkId in top10_talkIds:
        recommendedTalkByTopics.append(talkIds_title_dict[talkId])

    metaData = loadPickle("miniTEDMetaData.pickle")

    searchResults = st.expander("Expand to see Search Results by Topic ", expanded=True)
    with searchResults:
        col1, col2 = st.columns(2)
        with col1:
            talk = recommendedTalkByTopics[0]
            showRecommendation(talk, metaData)

        with col2:
            talk = recommendedTalkByTopics[1]
            showRecommendation(talk, metaData)

        col1, col2 = st.columns(2)
        with col1:
            talk = recommendedTalkByTopics[2]
            showRecommendation(talk, metaData)

        with col2:
            talk = recommendedTalkByTopics[3]
            showRecommendation(talk, metaData)

        col1, col2 = st.columns(2)
        with col1:
            talk = recommendedTalkByTopics[4]
            showRecommendation(talk, metaData)

        with col2:
            talk = recommendedTalkByTopics[5]
            showRecommendation(talk, metaData)

    st.write("----")
    st.header("Get Recommendations or Related Ted Talks")
    st.subheader("Make Selection based on above topics to get Recommendations")
    ted_talk = st.selectbox(label="Select your favourite TED Talk",
                            options=recommendedTalkByTopics)

    # cosineSimilarityMatrix = loadPickle("TED_CosineSimilarityMatrix.pickle")

    # gif_runner = st.image(DATA_PATH + "wait.gif")
    # if cosineSimilarityMatrixCalculated==False:
    #     cosineSimilarityMatrixCalculated,cosineSimilarityMatrix = getCosineSimilarityMatrix()
    # else:
    #     gif_runner.empty()

    index_title_dict = dict(zip(list(metaData.index), metaData['title']))
    title_index_dict = {title: index for index, title in index_title_dict.items()}

    top_10_similar_tedTalks = sorted(list(enumerate(cosineSimilarityMatrix[title_index_dict[ted_talk]])),
                                     reverse=True, key=(lambda x: x[1]))[1:11]

    top_10_similar_tedTalks_indices = [mostSimilarTalk[0] for mostSimilarTalk in top_10_similar_tedTalks]

    recommendedTalkByContent = []
    for index in top_10_similar_tedTalks_indices:
        recommendedTalkByContent.append(index_title_dict[index])
    st.subheader("Recommended TED Talks")
    recommendationResults = st.expander("Expand to see Recommended Ted Talks ", expanded=False)
    with recommendationResults:
        col1, col2 = st.columns(2)
        with col1:
            talk = recommendedTalkByContent[0]
            showRecommendation(talk, metaData)

        with col2:
            talk = recommendedTalkByContent[1]
            showRecommendation(talk, metaData)

        col1, col2 = st.columns(2)
        with col1:
            talk = recommendedTalkByContent[2]
            showRecommendation(talk, metaData)

        with col2:
            talk = recommendedTalkByContent[3]
            showRecommendation(talk, metaData)

        col1, col2 = st.columns(2)
        with col1:
            talk = recommendedTalkByContent[4]
            showRecommendation(talk, metaData)

        with col2:
            talk = recommendedTalkByContent[5]
            showRecommendation(talk, metaData)

        col1, col2 = st.columns(2)
        with col1:
            talk = recommendedTalkByContent[6]
            showRecommendation(talk, metaData)

        with col2:
            talk = recommendedTalkByContent[7]
            showRecommendation(talk, metaData)

        col1, col2 = st.columns(2)
        with col1:
            talk = recommendedTalkByContent[8]
            showRecommendation(talk, metaData)

        with col2:
            talk = recommendedTalkByContent[9]
            showRecommendation(talk, metaData)

    st.subheader("Related TED Talk")
    relatedResults = st.expander("Expand to see Related Ted Talks ", expanded=False)
    with relatedResults:
        relatedTalkList = list(getRelatedTalks(talk, metaData))
        for i, relatedTalk in enumerate(relatedTalkList):

            col = st.columns(1)

            st.subheader(relatedTalk)
            st.write(getTalkDescription(relatedTalk, metaData))
            url = getTalkURL(relatedTalk, metaData)
            if st.button("TED Talk Link", key=url + str(i)):
                #webbrowser.open_new_tab(url)
                #pc.copy(url)
                st.info("The Link: {}".format(url))
